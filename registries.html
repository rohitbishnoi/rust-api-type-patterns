<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Registries - Rust API Type Patterns</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="main_idea.html"><strong aria-hidden="true">2.</strong> The Main Idea</a></li><li class="chapter-item expanded "><a href="access_control.html"><strong aria-hidden="true">3.</strong> Access Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="witnesses.html"><strong aria-hidden="true">3.1.</strong> Witnesses</a></li><li class="chapter-item expanded "><a href="guards.html"><strong aria-hidden="true">3.2.</strong> Guards</a></li></ol></li><li class="chapter-item expanded "><a href="state_machines.html"><strong aria-hidden="true">4.</strong> State Machines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="typestate.html"><strong aria-hidden="true">4.1.</strong> Typestate</a></li><li class="chapter-item expanded "><a href="state_combinators.html"><strong aria-hidden="true">4.2.</strong> State Combinators</a></li></ol></li><li class="chapter-item expanded "><a href="parallel_lists.html"><strong aria-hidden="true">5.</strong> Parallel Lists</a></li><li class="chapter-item expanded "><a href="registries.html" class="active"><strong aria-hidden="true">6.</strong> Registries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust API Type Patterns</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#registries" id="registries">Registries</a></h1>
<p>Extensible systems, or frameworks where the client plugs in their own functionality, often have a notion of &quot;registration&quot; to associate the user's code with a piece of the framework. For example:</p>
<ul>
<li>In event systems, users can register callbacks to be triggered when an event occurs.</li>
<li>In dependency injection systems, users register dependencies which gets plumbed to other code that is registered to request that dependency.</li>
</ul>
<p>These systems use <strong>registries</strong> to maintain sets of event listeners or dependencies. The key API design challenge is to maintain consistency between the registered objects and the code that reads the registry. As a running example, we will use an event system. Consider this API that works like JavaScript's <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener"><code>addEventListener</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::any::Any;
</span><span class="boring">use std::collections::HashMap;
</span>type EventListener = Box&lt;dyn Fn(&amp;dyn Any)&gt;;

#[derive(Default)]
struct EventRegistry {
  listeners: HashMap&lt;String, Vec&lt;EventListener&gt;&gt;
}

impl EventRegistry {
  fn add_event_listener(&amp;mut self, event: String, f: EventListener) {
    self.listeners.entry(event).or_insert_with(Vec::new).push(f);
  }

  fn trigger(&amp;self, event: String, data: &amp;dyn Any) {
    let listeners = self.listeners.get(&amp;event).unwrap();
    for listener in listeners.iter() {
      listener(data);
    }
  }
}

struct OnClick { mouse_x: f32, mouse_y: f32 }

fn main() {
  let mut events = EventRegistry::default();
  events.add_event_listener(&quot;click&quot;.to_owned(), Box::new(|event| {
    let event = event.downcast_ref::&lt;OnClick&gt;().unwrap();
    assert_eq!(event.mouse_x, 1.);
  }));

  let event = OnClick { mouse_x: 1., mouse_y: 3. };
  events.trigger(&quot;click&quot;.to_owned(), &amp;event);
}
</code></pre></pre>
<p>How could a user incorrectlmouse_y work with this API? They could:</p>
<ul>
<li>
<p><strong>Typo the event name</strong>: as with all stringly-typed programming, the event name could be the wrong string, like <code>&quot;clack&quot;</code> instead of <code>&quot;click&quot;</code>, for either the listener or the trigger.</p>
</li>
<li>
<p><strong>Send the wrong payload for an event</strong>: event listeners take literally any type as input. A user could trigger a <code>MouseEvent</code> for the <code>&quot;click&quot;</code> string.</p>
</li>
<li>
<p><strong>Use the event payload incorrectly:</strong>: a user could incorrectly cast the payload to <code>MouseEvent</code> for a listener to the <code>&quot;click&quot;</code> event.</p>
</li>
</ul>
<p>The core issue is that the event name <code>&quot;click&quot;</code> and the event data <code>OnClick</code> are linked by convention but not by design. This issue is inherent to registries that use strings to identify objects.</p>
<p>Instead, I will show you how to design both an event system and a dependency injection system using <strong>types as keys intead of strings as keys</strong>. Type-based registries will avoid all of the issues in the API above.</p>
<h2><a class="header" href="#1-type-safe-events" id="1-type-safe-events">1. Type-safe events</a></h2>
<p>Our goal is to write an API that looks like this from the client's perspective:</p>
<pre><code class="language-rust ignore">struct OnClick {
  mouse_x: f32,
  mouse_y: f32,
}

let mut events = EventRegistry::new();

// The event is passed in as a type parameter instead of a string
events.add_event_listener::&lt;OnClick&gt;(|event| {
  assert_eq!(event.mouse_x, 10.);
  assert_eq!(event.mouse_y, 5.);
});

// The event type could alternatively be inferred from the closure
events.add_event_listener(|event: &amp;OnClick| {
  assert_eq!(event.mouse_x, 10.);
  assert_eq!(event.mouse_y, 5.);
});

events.trigger(&amp;OnClick {
  mouse_x: 10.,
  mouse_y: 5.,
})
</code></pre>
<p>The outline of the underlying API looks like this:</p>
<pre><code class="language-rust ignore">trait Event = 'static;
trait EventListener&lt;E&gt; = Fn(&amp;E) -&gt; () + 'static;

struct EventRegistry { /* .. */ };

impl EventRegistry {
  fn add_event_listener&lt;E: Event&gt;(
    &amp;mut self,
    f: impl EventListener&lt;E&gt;
  ) {
    /* .. */
  }

  fn trigger&lt;E: Event&gt;(
    &amp;self,
    event: &amp;E
  ) {
    /* .. */
  }
}
</code></pre>
<p>Each method on the event registry takes an event type <code>E</code> as input, rather than a string key. The registry associates listeners with that type, and then looks up listeners with that type.</p>
<h3><a class="header" href="#mapping-types-to-values" id="mapping-types-to-values">Mapping types to values</a></h3>
<p>To associate values (e.g. event listeners) with types, we will make a core building block: the <code>TypeMap</code>.</p>
<p>Rust has <a href="https://doc.rust-lang.org/std/any/"><code>std::any</code></a> for this purpose. <a href="https://doc.rust-lang.org/std/any/struct.TypeId.html"><code>TypeId</code></a> allows us to get a unique, hashable identifier for each type. <a href="https://doc.rust-lang.org/std/any/trait.Any.html"><code>Any</code></a> allows us to up-cast/down-cast objects at runtime. Hence, our <code>TypeMap</code> will map from <code>TypeId</code> to <code>Box&lt;dyn Any&gt;</code>.</p>
<pre><code class="language-rust ignore">use std::collections::HashMap;
use std::any::{TypeId, Any};

struct TypeMap(HashMap&lt;TypeId, Box&lt;dyn Any&gt;&gt;);
</code></pre>
<p>To add an element to the map:</p>
<pre><code class="language-rust ignore">impl TypeMap {
  pub fn set&lt;T: Any + 'static&gt;(&amp;mut self, t: T) {
    self.0.insert(TypeId::of::&lt;T&gt;(), Box::new(t));
  }
}
</code></pre>
<p>This means our map has one unique value for a given type. For example, if we use the <code>TypeMap</code> like this:</p>
<pre><code class="language-rust ignore">let mut map = TypeMap::new();
map.set::&lt;i32&gt;(1);
</code></pre>
<blockquote>
<p>Aside: the syntax <code>::&lt;i32&gt;</code> is Rust's &quot;turbofish&quot;. It explicitly binds a type parameter of a polymorphic function, rather than leaving it to be inferred. <a href="https://stackoverflow.com/questions/52360464/what-is-the-syntax-instance-methodsomething/52361559">Further</a> <a href="https://matematikaadit.github.io/posts/rust-turbofish.html">explanation</a> <a href="https://techblog.tonsser.com/posts/what-is-rusts-turbofish">here</a>.</p>
</blockquote>
<p>Then we insert a value <code>1</code> at the key <code>TypeId::of::&lt;i32&gt;()</code>. We can also implement <code>has</code> and <code>get</code> functions:</p>
<pre><code class="language-rust ignore">impl TypeMap {
  pub fn has&lt;T: Any + 'static&gt;(&amp;self) -&gt; bool {
    self.0.contains_key(&amp;TypeId::of::&lt;T&gt;())
  }

  pub fn get_mut&lt;T: Any + 'static&gt;(&amp;mut self) -&gt; Option&lt;&amp;mut T&gt; {
    self.0.get_mut(&amp;TypeId::of::&lt;T&gt;()).map(|t| {
      t.downcast_mut::&lt;T&gt;().unwrap()
    })
  }
}
</code></pre>
<p>Look carefully at <code>get_mut</code>. The inner hash map returns a value of type <code>Box&lt;dyn Any&gt;</code>, which we can <code>downcast_mut</code> to become a value of type <code>&amp;mut T</code>. This operation is guaranteed to not fail, because only values of type <code>T</code> are stored in the hash map under the key for <code>T</code>.</p>
<h3><a class="header" href="#implementing-the-event-system" id="implementing-the-event-system">Implementing the event system</a></h3>
<p>With the <code>TypeMap</code> in hand, we can finish our event system. For the <code>EventRegistry</code>, the <code>TypeMap</code> will map from events to a vector of listeners.</p>
<pre><code class="language-rust ignore">struct EventDispatcher(TypeMap);
type ListenerVec&lt;E&gt; = Vec&lt;Box&lt;dyn EventListener&lt;E&gt;&gt;&gt;;

impl EventDispatcher {
  fn add_event_listener&lt;E&gt;(&amp;mut self, f: impl EventListener&lt;E&gt;) {
    if !self.0.has::&lt;ListenerVec&lt;E&gt;&gt;() {
      self.0.set::&lt;ListenerVec&lt;E&gt;&gt;(Vec::new());
    }

    let listeners = self.0.get_mut::&lt;ListenerVec&lt;E&gt;&gt;().unwrap();
    listeners.push(Box::new(f));
  }

  fn trigger&lt;E&gt;(&amp;self, event: &amp;E) {
    if let Some(listeners) = self.0.get::&lt;ListenerVec&lt;E&gt;&gt;() {
      for callback in listeners {
        callback(event);
      }
    }
  }
}
</code></pre>
<p>Returning to our API design goals, this design enforces consistency between related elements: an event listener's payload must match the event it's registered to.</p>
<h2><a class="header" href="#2-type-safe-dependency-injection" id="2-type-safe-dependency-injection">2. Type-safe dependency injection</a></h2>
<p>We'll walk through another example of using type registries to avoid unsafe string-based design. The basic idea of dependency injection (DI) is that you have a component that depends on another, like a web server using a database. However, you don't want to hard-code a particular database constructor, and rather make it easy to swap in different databases. For example:</p>
<pre><code class="language-rust ignore">trait Database {
  fn name(&amp;self) -&gt; &amp;'static str;
}

struct MySQL;
impl Database for MySQL {
  fn name(&amp;self) -&gt; &amp;'static str { &quot;MySQL&quot; }
}

struct Postgres;
impl Database for Postgres {
  fn name(&amp;self) -&gt; &amp;'static str { &quot;Postgres&quot; }
}

struct WebServer { db: Box&lt;dyn Database&gt; }
impl WebServer {
  fn run(&amp;self) {
    println!(&quot;Db name: {}&quot;, self.db.name());
  }
}
</code></pre>
<p>To implement DI, we need two things:</p>
<ul>
<li>We need a way to register a global <code>Database</code> at runtime to a particular instance, e.g. <code>MySQL</code> or <code>Postgres</code>.</li>
<li>We need a way to describe a constructor for <code>WebServer</code> that fetches the registered <code>Database</code> instance.</li>
</ul>
<p>With these pieces, we can use our DI system like so:</p>
<pre><code class="language-rust ignore">let mut manager = DIManager::new();
manager.build::&lt;MySQL&gt;().unwrap();
let server = manager.build::&lt;WebServer&gt;().unwrap();
server.lock().unwrap().run(); // prints Db name: MySQL
</code></pre>
<h3><a class="header" href="#di-constructors" id="di-constructors">DI constructors</a></h3>
<p>First, we'll define a trait <code>DIBuilder</code> that represents a constructor within our DI system.</p>
<pre><code class="language-rust ignore">trait DIBuilder {
  type Input;
  type Output;

  fn build(input: Self::Input) -&gt; Self::Output;
}
</code></pre>
<p>The <code>build</code> method is a static method (doesn't take <code>self</code> as input). It just takes <code>Input</code> as input, and produces <code>Output</code> as output. The key idea is that because <code>Input</code> and <code>Output</code> are <a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types">associated types</a>, we can inspect them later on. We will need to find values for <code>Input</code> and to store <code>Output</code> in our DI manager.</p>
<p>We implement <code>DIBuilder</code> for each type in the system. The databases have no inputs, so their input is <code>()</code>. Their return type is <code>Box&lt;dyn Database&gt;</code>, meaning they are explicitly cast to a trait object so they can be used interchangeably.</p>
<pre><code class="language-rust ignore">impl DIBuilder for MySQL {
  type Input = ();
  type Output = Box&lt;dyn Database&gt;;
  fn build((): ()) -&gt; Box&lt;dyn Database&gt; {
    Box::new(MySQL)
  }
}

impl DIBuilder for Postgres {
  type Input = ();
  type Output = Box&lt;dyn Database&gt;;
  fn build((): ()) -&gt; Box&lt;dyn Database&gt; {
    Box::new(Postgres)
  }
}

impl DIBuilder for WebServer {
  type Input = (Box&lt;dyn Database&gt;,);
  type Output = WebServer;

  fn build((db,): Self::Input) -&gt; WebServer {
    WebServer { db }
  }
}
</code></pre>
<h3><a class="header" href="#di-manager" id="di-manager">DI manager</a></h3>
<p>Now that we know the dependency structure of our objects, we need a centralized manager to store the objects and fetch their dependencies.</p>
<pre><code class="language-rust ignore">struct DIManager(TypeMap);
</code></pre>
<p>In this <code>TypeMap</code>, we will store the constructed objects. For example, once we make a <code>Box&lt;dyn Database&gt;</code>, then we will map <code>TypeId::of::&lt;Box&lt;dyn Database&gt;&gt;</code> to one of <code>Box&lt;Postgres&gt;</code> or <code>Box&lt;MySQL&gt;</code>.</p>
<pre><code class="language-rust ignore">impl DIManager {
  fn build&lt;T: DIBuilder&gt;(&amp;mut self) -&gt; Option&lt;T::Output&gt; {
    let input = /* get the inputs, somehow */;
    let obj = T::build(input);
    self.0.set::&lt;T::Output&gt;(obj);
    Some(obj)
  }
}
</code></pre>
<p>Ignoring how we fetch dependencies for now, this function calls the <code>DIBuilder::build</code> implementation for <code>T</code>, then stores the result in the <code>TypeMap</code>. This approach <em>almost</em> works, except not for Rust: ownership of <code>obj</code> is passed into <code>TypeMap</code> and the result of <code>build</code>.</p>
<p>And, intuitively, this makes sense. If a component like a database cursor needs to be shared across many downstream components, it needs some kind of access protection. Hence, we tweak our interface a bit to wrap everything in an <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> and <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>.</p>
<pre><code class="language-rust ignore">type DIObj&lt;T&gt; = Arc&lt;Mutex&lt;T&gt;&gt;;

impl DIManager {
  fn build&lt;T: DIBuilder&gt;(&amp;mut self) -&gt; Option&lt;DIObj&lt;T::Output&gt;&gt; {
    let input = /* get the inputs, somehow */;
    let obj = T::build(input);
    let sync_obj = Arc::new(Mutex::new(obj));
    self.0.set::&lt;DIObj&lt;T::Output&gt;&gt;(sync_obj.clone());
    Some(sync_obj)
  }
}
</code></pre>
<h3><a class="header" href="#di-dependencies" id="di-dependencies">DI dependencies</a></h3>
<p>Finally, we need a way to implement the <code>let input</code> line in <code>DIManager::build</code>. Given a type <code>T: DIBuilder</code>, it has an associated type <code>T::Input</code> that represents the inputs needed to build it.</p>
<p>To simplify the problem, imagine <code>T::Input = S</code> where <code>S: DIBuilder</code>. Then if <code>S</code> has already been built, e.g. <code>T = WebServer</code> and <code>S = Box&lt;dyn Database&gt;</code>, we can fetch it directly from the typemap:</p>
<pre><code class="language-rust ignore">let input = self.0.get::&lt;T::Input&gt;().map(|obj| obj.clone())?;
</code></pre>
<p>However, in practice <code>T::Input</code> could be several dependencies. For example, if our server depends on a configuration, it might be:</p>
<pre><code class="language-rust ignore">impl DIBuilder for WebServer {
  type Input = (Box&lt;dyn Database&gt;, Box&lt;dyn ServerConfig&gt;);
  type Output = WebServer;

  fn build((db, config): Self::Input) -&gt; WebServer {
    WebServer { db, config }
  }
}
</code></pre>
<p>Let's assume now <code>T::Input</code> is always a tuple <code>(S1, S2, ...)</code> of types where each type <code>Si : DIBuilder</code>. Ideally, we could write something like:</p>
<pre><code class="language-rust ignore">let input = (T::Input).map(|S| {
  self.0.get::&lt;S&gt;().map(|obj| obj.clone()).unwrap()
});
</code></pre>
<p>But, alas, our language of expressions is not our language of types. Such a thing is the provenance of languages we can only <a href="https://leanprover.github.io/">dream about</a>. Instead, we have to cleverly use traits to inductively define a way to extract inputs from the tuple. To start, we'll make a trait that gets an object of a particular type from the <code>DIManager</code>:</p>
<pre><code class="language-rust ignore">trait GetInput: Sized {
  fn get_input(manager: &amp;DIManager) -&gt; Option&lt;Self&gt;;
}
</code></pre>
<p>For <code>DIObj&lt;T&gt;</code>, this means looking up the type in the <code>TypeMap</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T: 'static&gt; GetInput for DIObj&lt;T&gt; {
  fn get_input(manager: &amp;DIManager) -&gt; Option&lt;Self&gt; {
    manager.0.get::&lt;Self&gt;().map(|obj| obj.clone())
  }
}
</code></pre>
<p>Then for tuples of <code>DIObj&lt;T&gt;</code>, we can make an inductive definition like so:</p>
<pre><code class="language-rust ignore">impl GetInput for () {
  fn get_input(_manager: &amp;DIManager) -&gt; Option&lt;Self&gt; {
    Some(())
  }
}

impl&lt;S: GetInput, T: GetInput&gt; GetInput for (S, T) {
  fn get_input(manager: &amp;DIManager) -&gt; Option&lt;Self&gt; {
    S::get_input(manager).and_then(|s| {
      T::get_input(manager).and_then(|t| {
        Some((s, t))
      })
    })
  }
}
</code></pre>
<p>Then we can modify our <code>WebServer</code> example to use an inductive structure:</p>
<pre><code class="language-rust ignore">impl DIBuilder for WebServer {
  type Input = (DIObj&lt;Box&lt;dyn Database&gt;&gt;,(DIObj&lt;Box&lt;dyn ServerConfig&gt;&gt;,()));
  type Output = WebServer;

  fn build((db, (config, ())): Self::Input) -&gt; WebServer {
    WebServer { db, config }
  }
}
</code></pre>
<blockquote>
<p>Aside: in practice, rather than doing nested pairs, you can use a macro to create the <code>GetInput</code> impl for many tuple types <a href="https://github.com/amethyst/shred/blob/0.10.2/src/system.rs#L438-L469">like this</a>.</p>
</blockquote>
<p>And at last, we can implement <code>DIManager::build</code>:</p>
<pre><code class="language-rust ignore">impl DIManager {
  pub fn build&lt;T: DIBuilder&gt;(&amp;mut self) -&gt; Option&lt;DIObj&lt;T::Output&gt;&gt; {
    let input = T::Input::get_input(self)?;
    let obj = T::build(input);
    let sync_obj = Arc::new(Mutex::new(obj));
    self.0.set::&lt;DIObj&lt;T::Output&gt;&gt;(sync_obj.clone());
    Some(sync_obj)
  }
}
</code></pre>
<p>Now, the expression <code>T::Input::get_input(self)</code> will convert a tuple of types into a tuple of values of those types.</p>
<h3><a class="header" href="#final-api-example" id="final-api-example">Final API example</a></h3>
<p>With the API complete, our example now looks like this:</p>
<pre><code class="language-rust ignore">let mut manager = DIManager::new();
manager.build::&lt;MySQL&gt;().unwrap();
let server = manager.build::&lt;WebServer&gt;().unwrap();
server.lock().unwrap().run();
</code></pre>
<p>We can construct a <code>WebServer</code> without explicitly passing in a <code>dyn Database</code> instance. When we use the <code>server</code>, we have to explicitly call <code>.lock()</code> now that it's wrapped in a mutex. And lo, our dependencies have been injected.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="parallel_lists.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="parallel_lists.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
